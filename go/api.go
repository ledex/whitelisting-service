/*
 * whitelisting-api
 *
 * This API is used to whitelist members on our minecraft-server
 *
 * API version: 1.0
 * Generated by: Swagger Codegen (https://github.com/swagger-api/swagger-codegen.git)
 */
package swagger

import (
	"bytes"
	"encoding/json"
	"github.com/google/uuid"
	"github.com/gorilla/mux"
	"io/ioutil"
	"net/http"
)

func DeleteMembersId(w http.ResponseWriter, r *http.Request) {
	if !auth(w,r){
		return
	}

	params := mux.Vars(r)
	id := params["username"]
	idAsUuid, _ := uuid.Parse(id)

	var we []WhitelistEntry
	err := readWhitelist("test.json", &we)
	if err != nil {
		writeLogToWriter(w, Error, "E001", "Could not read whitelist. Check permissions.")
		return
	}

	for index, entry := range we {
		if entry.Id == idAsUuid || entry.Name == id {
			we = removeEntry(we, index)
			break
		}
	}

	err = writeWhitelist("test.json", &we)
	if err != nil {
		writeLogToWriter(w, Error, "E001", "Could not write back whitelist. Check permissions.")
		return
	}

	writeLogToWriter(w, Info, "I002", "User has been removed from the whitelist")
}

func GetMembers(w http.ResponseWriter, r *http.Request){
	if !auth(w,r){
		return
	}

	file, err := ioutil.ReadFile("test.json")
	if err != nil {
		writeLogToWriter(w, Error, "E001", "Could not read whitelist. Check permissions.")
		return
	}

	w.WriteHeader(http.StatusOK)
	w.Write(file)
}

func PostMembers(w http.ResponseWriter, r *http.Request) {

	if !auth(w,r){
		return
	}

	//Checks if request is valid
	var b Body

	err := json.NewDecoder(r.Body).Decode(&b)
	if err != nil {
		http.Error(w, err.Error(), http.StatusBadRequest)
		return
	}

	//Gets user-details from mojang
	client := &http.Client{}
	req, _ := http.NewRequest("GET", "https://api.mojang.com/users/profiles/minecraft/" + b.Username, nil)
	req.Header.Set("Accept", "*/*")
	req.Header.Set("User-Agent", "PostmanRuntime/7.22.0")
	res, err := client.Do(req)

	if err != nil || res.StatusCode !=http.StatusOK {
		writeLogToWriter(w, Error, "E002", "Username is invalid.")
		return
	}

	var mu MojangUser

	buf := new(bytes.Buffer)
	buf.ReadFrom(res.Body)

	err = json.NewDecoder(bytes.NewReader(buf.Bytes())).Decode(&mu)

	if err != nil {
		writeLogToWriter(w, Error, "E-1", err.Error())
		return
	}

	//Adds user to whitelist

	newWe := WhitelistEntry{
		Id:   mu.Id,
		Name: mu.Name,
	}

	var we []WhitelistEntry
	err = readWhitelist("test.json", &we)
	if err != nil {
		writeLogToWriter(w, Error, "E001", "Could not read whitelist. Check permissions.")
 		return
	}

	for _, entry := range we {
		if entry.Id == newWe.Id {
			writeLogToWriter(w, Info, "I001", "User is already whitelisted")
			return
		}
	}

	we = append(we, newWe)

	err = writeWhitelist("test.json", &we)
	if err != nil {
		writeLogToWriter(w, Error, "E001", "Could not write back whitelist. Check permissions.")
		return
	}

	result, _ := json.MarshalIndent(newWe, "", " ")

	w.WriteHeader(http.StatusCreated)
	w.Write(result)

}

func auth(w http.ResponseWriter, r *http.Request) bool {
	apiKeys, ok := r.URL.Query()["apiKey"]
	if !ok || len(apiKeys) != 1 {
		http.Error(w, "The url-param 'apiKey' was not specified or was specified multiple times.", http.StatusBadRequest)
		return false
	}
	if apiKeys[0] != "12345" /*os.Getenv("globalApiKey")*/{
		http.Error(w, "The given 'apiKey' is not valid.", http.StatusUnauthorized)
		return false
	}

	return true
}

func removeEntry(s []WhitelistEntry, i int) []WhitelistEntry {
	s[len(s)-1], s[i] = s[i], s[len(s)-1]
	return s[:len(s)-1]
}
